/*
25. K 个一组翻转链表    60      https://study-cn.com/problems/reverse-nodes-in-k-group
3. 无重复字符的最长子串 57      https://study-cn.com/problems/longest-substring-without-repeating-characters
146. LRU缓存机制        53      https://study-cn.com/problems/lru-cache
215. 数组中的第K个最大元素      52      https://study-cn.com/problems/kth-largest-element-in-an-array
206. 反转链表   51      https://study-cn.com/problems/reverse-linked-list
103. 二叉树的锯齿形层次遍历     47      https://study-cn.com/problems/binary-tree-zigzag-level-order-traversal
15. 三数之和    42      https://study-cn.com/problems/3sum
121. 买卖股票的最佳时机 41      https://study-cn.com/problems/best-time-to-buy-and-sell-stock
160. 相交链表   32      https://study-cn.com/problems/intersection-of-two-linked-lists
236. 二叉树的最近公共祖先       32      https://study-cn.com/problems/lowest-common-ancestor-of-a-binary-tree
42. 接雨水      31      https://study-cn.com/problems/trapping-rain-water
33. 搜索旋转排序数组    27      https://study-cn.com/problems/search-in-rotated-sorted-array
31. 下一个排列  27      https://study-cn.com/problems/next-permutation
199. 二叉树的右视图     24      https://study-cn.com/problems/binary-tree-right-side-view
54. 螺旋矩阵    24      https://study-cn.com/problems/spiral-matrix
143. 重排链表   24      https://study-cn.com/problems/reorder-list
23. 合并K个排序链表     23      https://study-cn.com/problems/merge-k-sorted-lists
21. 合并两个有序链表    22      https://study-cn.com/problems/merge-two-sorted-lists
300. 最长上升子序列     21      https://study-cn.com/problems/longest-increasing-subsequence
69. x 的平方根  20      https://study-cn.com/problems/sqrtx
92. 反转链表 II 20      https://study-cn.com/problems/reverse-linked-list-ii
105. 从前序与中序遍历序列构造二叉树     19      https://study-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal
1. 两数之和     19      https://study-cn.com/problems/two-sum
124. 二叉树中的最大路径和       18      https://study-cn.com/problems/binary-tree-maximum-path-sum
200. 岛屿数量   18      https://study-cn.com/problems/number-of-islands
41. 缺失的第一个正数    17      https://study-cn.com/problems/first-missing-positive
101. 对称二叉树 16      https://study-cn.com/problems/symmetric-tree
56. 合并区间    16      https://study-cn.com/problems/merge-intervals
415. 字符串相加 16      https://study-cn.com/problems/add-strings
155. 最小栈     16      https://study-cn.com/problems/min-stack
46. 全排列      16      https://study-cn.com/problems/permutations
76. 最小覆盖子串        16      https://study-cn.com/problems/minimum-window-substring
补充题1. 排序奇升偶降链表       16      https://mp.weixin.qq.com/s/0WVa2wIAeG0nYnVndZiEXQ
141. 环形链表   14      https://study-cn.com/problems/linked-list-cycle
221. 最大正方形 14      https://study-cn.com/problems/maximal-square
20. 有效的括号  14      https://study-cn.com/problems/valid-parentheses
98. 验证二叉搜索树      14      https://study-cn.com/problems/validate-binary-search-tree
39. 组合总和    14      https://study-cn.com/problems/combination-sum
102. 二叉树的层序遍历   13      https://study-cn.com/problems/binary-tree-level-order-traversal
53. 最大子序和  13      https://study-cn.com/problems/maximum-subarray
322. 零钱兑换   13      https://study-cn.com/problems/coin-change
162. 寻找峰值   13      https://study-cn.com/problems/find-peak-element
122. 买卖股票的最佳时机 II      13      https://study-cn.com/problems/best-time-to-buy-and-sell-stock-ii
142. 环形链表 II        13      https://study-cn.com/problems/linked-list-cycle-ii
48. 旋转图像    13      https://study-cn.com/problems/rotate-image
470. 用 Rand7() 实现 Rand10()   13      https://study-cn.com/problems/implement-rand10-using-rand7
补充题2. 圆环回原点问题 13      https://mp.weixin.qq.com/s/NZPaFsFrTybO3K3s7p7EVg
234. 回文链表   12      https://study-cn.com/problems/palindrome-linked-list
518. 零钱兑换 II        12      https://study-cn.com/problems/coin-change-2
88. 合并两个有序数组    12      https://study-cn.com/problems/merge-sorted-array
2. 两数相加     12      https://study-cn.com/problems/add-two-numbers
32. 最长有效括号        12      https://study-cn.com/problems/longest-valid-parentheses
958. 二叉树的完全性检验 12      https://study-cn.com/problems/check-completeness-of-a-binary-tree
148. 排序链表   12      https://study-cn.com/problems/sort-list
198. 打家劫舍   12      https://study-cn.com/problems/house-robber
232. 用栈实现队列       12      https://study-cn.com/problems/implement-queue-using-stacks
补充题4. 手撕快速排序   12      https://study-cn.com/problems/sort-an-array
113. 路径总和 II        11      https://study-cn.com/problems/path-sum-ii
5. 最长回文子串 11      https://study-cn.com/problems/longest-palindromic-substring
543. 二叉树的直径       10      https://study-cn.com/problems/diameter-of-binary-tree
79. 单词搜索    10      https://study-cn.com/problems/word-search
82. 删除排序链表中的重复元素 II 10      https://study-cn.com/problems/remove-duplicates-from-sorted-list-ii
83. 删除排序链表中的重复元素    9       https://study-cn.com/problems/remove-duplicates-from-sorted-list
128. 最长连续序列       9       https://study-cn.com/problems/longest-consecutive-sequence
22. 括号生成    9       https://study-cn.com/problems/generate-parentheses
94. 二叉树的中序遍历    9       https://study-cn.com/problems/binary-tree-inorder-traversal
739. 每日温度   9       https://study-cn.com/problems/daily-temperatures
78. 子集        9       https://study-cn.com/problems/subsets
补充题9. 36进制加法     9       https://mp.weixin.qq.com/s/XcKQwnwCh5nZsz-DLHJwzQ
剑指 Offer 54. 二叉搜索树的第k大节点    8       https://study-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof
8. 字符串转换整数 (atoi)        8       https://study-cn.com/problems/string-to-integer-atoi
24. 两两交换链表中的节点        8       https://study-cn.com/problems/swap-nodes-in-pairs
114. 二叉树展开为链表   8       https://study-cn.com/problems/flatten-binary-tree-to-linked-list
剑指 Offer 22. 链表中倒数第k个节点      8       https://study-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof
93. 复原IP地址  8       https://study-cn.com/problems/restore-ip-addresses
440. 字典序的第K小数字  8       https://study-cn.com/problems/k-th-smallest-in-lexicographical-order
70. 爬楼梯      7       https://study-cn.com/problems/climbing-stairs
112. 路径总和   7       https://study-cn.com/problems/path-sum
695. 岛屿的最大面积     7       https://study-cn.com/problems/max-area-of-island
138. 复制带随机指针的链表       7       https://study-cn.com/problems/copy-list-with-random-pointer
19. 删除链表的倒数第N个节点     7       https://study-cn.com/problems/remove-nth-node-from-end-of-list
129. 求根到叶子节点数字之和     7       https://study-cn.com/problems/sum-root-to-leaf-numbers
662. 二叉树最大宽度     7       https://study-cn.com/problems/maximum-width-of-binary-tree
240. 搜索二维矩阵 II    7       https://study-cn.com/problems/search-a-2d-matrix-ii
556. 下一个更大元素 III 7       https://study-cn.com/problems/next-greater-element-iii
230. 二叉搜索树中第K小的元素    6       https://study-cn.com/problems/kth-smallest-element-in-a-bst
110. 平衡二叉树 6       https://study-cn.com/problems/balanced-binary-tree
328. 奇偶链表   6       https://study-cn.com/problems/odd-even-linked-list
460. LFU缓存    6       https://study-cn.com/problems/lfu-cache
64. 最小路径和  6       https://study-cn.com/problems/minimum-path-sum
61. 旋转链表    6       https://study-cn.com/problems/rotate-list
188. 买卖股票的最佳时机 IV      6       https://study-cn.com/problems/best-time-to-buy-and-sell-stock-iv
224. 基本计算器 6       https://study-cn.com/problems/basic-calculator
剑指 Offer 36. 二叉搜索树与双向链表     6       https://study-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof
226. 翻转二叉树 6       https://study-cn.com/problems/invert-binary-tree
209. 长度最小的子数组   6       https://study-cn.com/problems/minimum-size-subarray-sum
862. 和至少为 K 的最短子数组    6       https://study-cn.com/problems/shortest-subarray-with-sum-at-least-k
11. 盛最多水的容器      6       https://study-cn.com/problems/container-with-most-water
补充题7. 木头切割问题   6       https://mp.weixin.qq.com/s/FQma0bdAWbzLMmCKhZRk7w
补充题23. 检测循环依赖  6       https://mp.weixin.qq.com/s/pCRscwKqQdYYN7M1Sia7xA
108. 将有序数组转换为二叉搜索树 5       https://study-cn.com/problems/convert-sorted-array-to-binary-search-tree
1143. 最长公共子序列    5       https://study-cn.com/problems/longest-common-subsequence
297. 二叉树的序列化与反序列化   5       https://study-cn.com/problems/serialize-and-deserialize-binary-tree
560. 和为K的子数组      5       https://study-cn.com/problems/subarray-sum-equals-k
704. 二分查找   5       https://study-cn.com/problems/binary-search
670. 最大交换   5       https://study-cn.com/problems/maximum-swap
421. 数组中两个数的最大异或值   5       https://study-cn.com/problems/maximum-xor-of-two-numbers-in-an-array
104. 二叉树的最大深度   5       https://study-cn.com/problems/maximum-depth-of-binary-tree
135. 分发糖果   5       https://study-cn.com/problems/candy
151. 翻转字符串里的单词 5       https://study-cn.com/problems/reverse-words-in-a-string
287. 寻找重复数 5       https://study-cn.com/problems/find-the-duplicate-number
528. 按权重随机选择     5       https://study-cn.com/problems/random-pick-with-weight
91. 解码方法    5       https://study-cn.com/problems/decode-ways
59. 螺旋矩阵 II 5       https://study-cn.com/problems/spiral-matrix-ii
718. 最长重复子数组     5       https://study-cn.com/problems/maximum-length-of-repeated-subarray
139. 单词拆分   4       https://study-cn.com/problems/word-break
剑指 Offer 11. 旋转数组的最小数字       4       https://study-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof
62. 不同路径    4       https://study-cn.com/problems/unique-paths
剑指 Offer 51. 数组中的逆序对   4       https://study-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof
40. 组合总和 II 4       https://study-cn.com/problems/combination-sum-ii
1047. 删除字符串中的所有相邻重复项      4       https://study-cn.com/problems/remove-all-adjacent-duplicates-in-string
402. 移掉K位数字        4       https://study-cn.com/problems/remove-k-digits
169. 多数元素   4       https://study-cn.com/problems/majority-element
152. 乘积最大子数组     4       https://study-cn.com/problems/maximum-product-subarray
50. Pow(x, n)   4       https://study-cn.com/problems/powx-n
4. 寻找两个正序数组的中位数     4       https://study-cn.com/problems/median-of-two-sorted-arrays
456. 132模式    4       https://study-cn.com/problems/132-pattern
239. 滑动窗口最大值     4       https://study-cn.com/problems/sliding-window-maximum
722. 删除注释   4       https://study-cn.com/problems/remove-comments
1095. 山脉数组中查找目标值      4       https://study-cn.com/problems/find-in-mountain-array
72. 编辑距离    4       https://study-cn.com/problems/edit-distance
153. 寻找旋转排序数组中的最小值 4       https://study-cn.com/problems/find-minimum-in-rotated-sorted-array
补充题3. 求区间最小数乘区间和的最大值   4       https://mp.weixin.qq.com/s/UFv7pt_djjZoK_gzUBrRXA
补充题6. 手撕堆排序     4       https://study-cn.com/problems/sort-an-array
227. 基本计算器 II      4       https://study-cn.com/problems/basic-calculator-ii
763. 划分字母区间       4       https://study-cn.com/problems/partition-labels
剑指 Offer 53 - I. 在排序数组中查找数字 I       4       https://study-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof
剑指 Offer 61. 扑克牌中的顺子   3       https://study-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof
977. 有序数组的平方     3       https://study-cn.com/problems/squares-of-a-sorted-array
剑指 Offer 09. 用两个栈实现队列 3       https://study-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof
503. 下一个更大元素 II  3       https://study-cn.com/problems/next-greater-element-ii
283. 移动零     3       https://study-cn.com/problems/move-zeroes
166. 分数到小数 3       https://study-cn.com/problems/fraction-to-recurring-decimal
264. 丑数 II    3       https://study-cn.com/problems/ugly-number-ii
210. 课程表 II  3       https://study-cn.com/problems/course-schedule-ii
394. 字符串解码 3       https://study-cn.com/problems/decode-string
145. 二叉树的后序遍历   3       https://study-cn.com/problems/binary-tree-postorder-traversal
71. 简化路径    3       https://study-cn.com/problems/simplify-path
134. 加油站     3       https://study-cn.com/problems/gas-station
340. 至多包含 K 个不同字符的最长子串    3       https://study-cn.com/problems/longest-substring-with-at-most-k-distinct-characters
86. 分隔链表    3       https://study-cn.com/problems/partition-list
329. 矩阵中的最长递增路径       3       https://study-cn.com/problems/longest-increasing-path-in-a-matrix
144. 二叉树的前序遍历   3       https://study-cn.com/problems/binary-tree-preorder-traversal
10. 正则表达式匹配      3       https://study-cn.com/problems/regular-expression-matching
剑指 Offer 46. 把数字翻译成字符串       3       https://study-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof
136. 只出现一次的数字   3       https://study-cn.com/problems/single-number
18. 四数之和    3       https://study-cn.com/problems/4sum
剑指 Offer 27. 二叉树的镜像     3       https://study-cn.com/problems/er-cha-shu-de-jing-xiang-lcof
225. 用队列实现栈       3       https://study-cn.com/problems/implement-stack-using-queues
647. 回文子串   3       https://study-cn.com/problems/palindromic-substrings
34. 在排序数组中查找元素的第一个和最后一个位置  3       https://study-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array
165. 比较版本号 3       https://study-cn.com/problems/compare-version-numbers
887. 鸡蛋掉落   3       https://study-cn.com/problems/super-egg-drop
106. 从中序与后序遍历序列构造二叉树     3       https://study-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal
498. 对角线遍历 3       https://study-cn.com/problems/diagonal-traverse
354. 俄罗斯套娃信封问题 3       https://study-cn.com/problems/russian-doll-envelopes
767. 重构字符串 3       https://study-cn.com/problems/reorganize-string
1254. 统计封闭岛屿的数目        2       https://study-cn.com/problems/number-of-closed-islands
347. 前 K 个高频元素    2       https://study-cn.com/problems/top-k-frequent-elements
剑指 Offer 10- II. 青蛙跳台阶问题       2       https://study-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof
剑指 Offer 45. 把数组排成最小的数       2       https://study-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof
99. 恢复二叉搜索树      2       https://study-cn.com/problems/recover-binary-search-tree
125. 验证回文串 2       https://study-cn.com/problems/valid-palindrome
剑指 Offer 21. 调整数组顺序使奇数位于偶数前面   2       https://study-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof
523. 连续的子数组和     2       https://study-cn.com/problems/continuous-subarray-sum
剑指 Offer 48. 最长不含重复字符的子字符串       2       https://study-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof
剑指 Offer 04. 二维数组中的查找 2       https://study-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof
补充题24. 双栈排序      2       https://mp.weixin.qq.com/s/g_AqwsSEUwlRSevnStPkEA
208. 实现 Trie (前缀树) 2       https://study-cn.com/problems/implement-trie-prefix-tree
剑指 Offer 19. 正则表达式匹配   2       https://study-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof
895. 最大频率栈 2       https://study-cn.com/problems/maximum-frequency-stack
398. 随机数索引 2       https://study-cn.com/problems/random-pick-index
45. 跳跃游戏 II 2       https://study-cn.com/problems/jump-game-ii
416. 分割等和子集       2       https://study-cn.com/problems/partition-equal-subset-sum
668. 乘法表中第k小的数  2       https://study-cn.com/problems/kth-smallest-number-in-multiplication-table
120. 三角形最小路径和   2       https://study-cn.com/problems/triangle
123. 买卖股票的最佳时机 III     2       https://study-cn.com/problems/best-time-to-buy-and-sell-stock-iii
154. 寻找旋转排序数组中的最小值 II      2       https://study-cn.com/problems/find-minimum-in-rotated-sorted-array-ii
147. 对链表进行插入排序 2       https://study-cn.com/problems/insertion-sort-list
785. 判断二分图 2       https://study-cn.com/problems/is-graph-bipartite
468. 验证IP地址 2       https://study-cn.com/problems/validate-ip-address
295. 数据流的中位数     2       https://study-cn.com/problems/find-median-from-data-stream
404. 左叶子之和 2       https://study-cn.com/problems/sum-of-left-leaves
84. 柱状图中最大的矩形  2       https://study-cn.com/problems/largest-rectangle-in-histogram
43. 字符串相乘  2       https://study-cn.com/problems/multiply-strings
14. 最长公共前缀        2       https://study-cn.com/problems/longest-common-prefix
974. 和可被 K 整除的子数组      2       https://study-cn.com/problems/subarray-sums-divisible-by-k
922. 按奇偶排序数组 II  2       https://study-cn.com/problems/sort-array-by-parity-ii
75. 颜色分类    2       https://study-cn.com/problems/sort-colors
191. 位1的个数  2       https://study-cn.com/problems/number-of-1-bits
60. 第k个排列   2       https://study-cn.com/problems/permutation-sequence
补充题10. 36进制减法    2       https://mp.weixin.qq.com/s/ub9GpTBjDF55hZld3V2rEA
补充题5. 手撕归并排序   2       https://study-cn.com/problems/sort-an-array
189. 旋转数组   2       https://study-cn.com/problems/rotate-array
74. 搜索二维矩阵        2       https://study-cn.com/problems/search-a-2d-matrix
补充题14. 阿拉伯数字转中文数字  2
剑指 Offer 03. 数组中重复的数字 2       https://study-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof
253. 会议室 II  2       https://study-cn.com/problems/meeting-rooms-ii
7. 整数反转     2       https://study-cn.com/problems/reverse-integer
47. 全排列 II   2       https://study-cn.com/problems/permutations-ii
85. 最大矩形    2       https://study-cn.com/problems/maximal-rectangle
81. 搜索旋转排序数组 II 2       https://study-cn.com/problems/search-in-rotated-sorted-array-ii
44. 通配符匹配  2       https://study-cn.com/problems/wildcard-matching
703. 数据流中的第K大元素        2       https://study-cn.com/problems/kth-largest-element-in-a-stream
443. 压缩字符串 2       https://study-cn.com/problems/string-compression
381. O(1) 时间插入、删除和获取随机元素 - 允许重复       2       https://study-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed
补充题20. 立方根        2
395. 至少有K个重复字符的最长子串        2       https://study-cn.com/problems/longest-substring-with-at-least-k-repeating-characters
剑指 Offer 52. 两个链表的第一个公共节点 1       https://study-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof
111. 二叉树的最小深度   1       https://study-cn.com/problems/minimum-depth-of-binary-tree
994. 腐烂的橘子 1       https://study-cn.com/problems/rotting-oranges
344. 反转字符串 1       https://study-cn.com/problems/reverse-string
1299. 将每个元素替换为右侧最大元素      1       https://study-cn.com/problems/replace-elements-with-greatest-element-on-right-side
67. 二进制求和  1       https://study-cn.com/problems/add-binary
515. 在每个树行中找最大值       1       https://study-cn.com/problems/find-largest-value-in-each-tree-row
1147. 段式回文  1       https://study-cn.com/problems/longest-chunked-palindrome-decomposition
876. 链表的中间结点     1       https://study-cn.com/problems/middle-of-the-linked-list
100. 相同的树   1       https://study-cn.com/problems/same-tree
842. 将数组拆分成斐波那契序列   1       https://study-cn.com/problems/split-array-into-fibonacci-sequence
剑指 Offer 33. 二叉搜索树的后序遍历序列 1       https://study-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof
剑指 Offer 38. 字符串的排列     1       https://study-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof
剑指 Offer 24. 反转链表 1       https://study-cn.com/problems/fan-zhuan-lian-biao-lcof
剑指 Offer 53 - II. 0～n-1中缺失的数字  1       https://study-cn.com/problems/que-shi-de-shu-zi-lcof
701. 二叉搜索树中的插入操作     1       https://study-cn.com/problems/insert-into-a-binary-search-tree
349. 两个数组的交集     1       https://study-cn.com/problems/intersection-of-two-arrays
1156. 单字符重复子串的最大长度  1       https://study-cn.com/problems/swap-for-longest-repeated-character-substring
449. 序列化和反序列化二叉搜索树 1       https://study-cn.com/problems/serialize-and-deserialize-bst
面试题 08.12. 八皇后    1       https://study-cn.com/problems/eight-queens-lcci
37. 解数独      1       https://study-cn.com/problems/sudoku-solver
410. 分割数组的最大值   1       https://study-cn.com/problems/split-array-largest-sum
694. 不同岛屿的数量     1       https://study-cn.com/problems/number-of-distinct-islands
剑指 Offer 18. 删除链表的节点   1       https://study-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof
912. 排序数组   1       https://study-cn.com/problems/sort-an-array
173. 二叉搜索树迭代器   1       https://study-cn.com/problems/binary-search-tree-iterator
1139. 最大的以 1 为边界的正方形 1       https://study-cn.com/problems/largest-1-bordered-square
剑指 Offer 25. 合并两个排序的链表       1       https://study-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof
325. 和等于 k 的最长子数组长度  1       https://study-cn.com/problems/maximum-size-subarray-sum-equals-k
1363. 形成三的最大倍数  1       https://study-cn.com/problems/largest-multiple-of-three
951. 翻转等价二叉树     1       https://study-cn.com/problems/flip-equivalent-binary-trees
107. 二叉树的层次遍历 II        1       https://study-cn.com/problems/binary-tree-level-order-traversal-ii
637. 二叉树的层平均值   1       https://study-cn.com/problems/average-of-levels-in-binary-tree
277. 搜寻名人   1       https://study-cn.com/problems/find-the-celebrity
321. 拼接最大数 1       https://study-cn.com/problems/create-maximum-number
525. 连续数组   1       https://study-cn.com/problems/contiguous-array
剑指 Offer 58 - II. 左旋转字符串        1       https://study-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof
97. 交错字符串  1       https://study-cn.com/problems/interleaving-string
204. 计数质数   1       https://study-cn.com/problems/count-primes
202. 快乐数     1       https://study-cn.com/problems/happy-number
1669. 合并两个链表      1       https://study-cn.com/problems/merge-in-between-linked-lists
807. 保持城市天际线     1       https://study-cn.com/problems/max-increase-to-keep-city-skyline
889. 根据前序和后序遍历构造二叉树       1       https://study-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal
剑指 Offer 05. 替换空格 1       https://study-cn.com/problems/ti-huan-kong-ge-lcof
279. 完全平方数 1       https://study-cn.com/problems/perfect-squares
17. 电话号码的字母组合  1       https://study-cn.com/problems/letter-combinations-of-a-phone-number
459. 重复的子字符串     1       https://study-cn.com/problems/repeated-substring-pattern
剑指 Offer 59 - II. 队列的最大值        1       https://study-cn.com/problems/dui-lie-de-zui-da-zhi-lcof
260. 只出现一次的数字 III       1       https://study-cn.com/problems/single-number-iii
1438. 绝对差不超过限制的最长连续子数组  1       https://study-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit
剑指 Offer 62. 圆圈中最后剩下的数字     1       https://study-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof
836. 矩形重叠   1       https://study-cn.com/problems/rectangle-overlap
1172. 餐盘栈    1       https://study-cn.com/problems/dinner-plate-stacks
547. 省份数量（原朋友圈）       1       https://study-cn.com/problems/number-of-provinces
面试题 17.24. 最大子矩阵        1       https://study-cn.com/problems/max-submatrix-lcci
1302. 层数最深叶子节点的和      1       https://study-cn.com/problems/deepest-leaves-sum
448. 找到所有数组中消失的数字   1       https://study-cn.com/problems/find-all-numbers-disappeared-in-an-array
127. 单词接龙   1       https://study-cn.com/problems/word-ladder
剑指 Offer 55 - II. 平衡二叉树  1       https://study-cn.com/problems/ping-heng-er-cha-shu-lcof
剑指 Offer 55 - I. 二叉树的深度 1       https://study-cn.com/problems/er-cha-shu-de-shen-du-lcof
面试题 08.05. 递归乘法  1       https://study-cn.com/problems/recursive-mulitply-lcci
179. 最大数     1       https://study-cn.com/problems/largest-number
1107. 每日新用户统计    1       https://study-cn.com/problems/new-users-daily-count
剑指 Offer 10- I. 斐波那契数列  1       https://study-cn.com/problems/fei-bo-na-qi-shu-lie-lcof
63. 不同路径 II 1       https://study-cn.com/problems/unique-paths-ii
397. 整数替换   1       https://study-cn.com/problems/integer-replacement
564. 寻找最近的回文数   1       https://study-cn.com/problems/find-the-closest-palindrome
765. 情侣牵手   1       https://study-cn.com/problems/couples-holding-hands
80. 删除排序数组中的重复项 II   1       https://study-cn.com/problems/remove-duplicates-from-sorted-array-ii
77. 组合        1       https://study-cn.com/problems/combinations
378. 有序矩阵中第K小的元素      1       https://study-cn.com/problems/kth-smallest-element-in-a-sorted-matrix
384. 打乱数组   1       https://study-cn.com/problems/shuffle-an-array
剑指 Offer 56 - I. 数组中数字出现的次数 1       https://study-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof
28. 实现 strStr()       1       https://study-cn.com/problems/implement-strstr
剑指 Offer 32 - III. 从上到下打印二叉树 III     1       https://study-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof
207. 课程表     1       https://study-cn.com/problems/course-schedule
386. 字典序排数 1       https://study-cn.com/problems/lexicographical-numbers
面试题 03.03. 堆盘子    1       https://study-cn.com/problems/stack-of-plates-lcci
331. 验证二叉树的前序序列化     1       https://study-cn.com/problems/verify-preorder-serialization-of-a-binary-tree
剑指 Offer 28. 对称的二叉树     1       https://study-cn.com/problems/dui-cheng-de-er-cha-shu-lcof
剑指 Offer 68 - II. 二叉树的最近公共祖先        1       https://study-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof
848. 字母移位   1       https://study-cn.com/problems/shifting-letters
6. Z 字形变换   1       https://study-cn.com/problems/zigzag-conversion
990. 等式方程的可满足性 1       https://study-cn.com/problems/satisfiability-of-equality-equations
567. 字符串的排列       1       https://study-cn.com/problems/permutation-in-string
496. 下一个更大元素 I   1       https://study-cn.com/problems/next-greater-element-i
967. 连续差相同的数字   1       https://study-cn.com/problems/numbers-with-same-consecutive-differences
1405. 最长快乐字符串    1       https://study-cn.com/problems/longest-happy-string
1353. 最多可以参加的会议数目    1       https://study-cn.com/problems/maximum-number-of-events-that-can-be-attended
1574. 删除最短的子数组使剩余数组有序    1       https://study-cn.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted
949. 给定数字能组成的最大时间   1       https://study-cn.com/problems/largest-time-for-given-digits
剑指 Offer 31. 栈的压入、弹出序列       1       https://study-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof
213. 打家劫舍 II        1       https://study-cn.com/problems/house-robber-ii
剑指 Offer 40. 最小的k个数      1       https://study-cn.com/problems/zui-xiao-de-kge-shu-lcof
1475. 商品折扣后的最终价格      1       https://study-cn.com/problems/final-prices-with-a-special-discount-in-a-shop
剑指 Offer 43. 1～n整数中1出现的次数    1       https://study-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof
706. 设计哈希映射       1       https://study-cn.com/problems/design-hashmap
252. 会议室     1       https://study-cn.com/problems/meeting-rooms
剑指 Offer 63. 股票的最大利润   1       https://study-cn.com/problems/gu-piao-de-zui-da-li-run-lcof
680. 验证回文字符串 Ⅱ   1       https://study-cn.com/problems/valid-palindrome-ii
341. 扁平化嵌套列表迭代器       1       https://study-cn.com/problems/flatten-nested-list-iterator
140. 单词拆分 II        1       https://study-cn.com/problems/word-break-ii
716. 最大栈     1       https://study-cn.com/problems/max-stack
214. 最短回文串 1       https://study-cn.com/problems/shortest-palindrome
633. 平方数之和 1       https://study-cn.com/problems/sum-of-square-numbers
补充题17. 两个有序数组第k小的数 1
589. N叉树的前序遍历    1       https://study-cn.com/problems/n-ary-tree-preorder-traversal
1675. 数组的最小偏移量  1       https://study-cn.com/problems/minimize-deviation-in-array
485. 最大连续1的个数    1       https://study-cn.com/problems/max-consecutive-ones
补充题8. 计算数组的小和 1       https://mp.weixin.qq.com/s/rMsbcUf9ZPhvfRoyZGW6HA
剑指 Offer 34. 二叉树中和为某一值的路径 1       https://study-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof
剑指 Offer 17. 打印从1到最大的n位数     1       https://study-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof
861. 翻转矩阵后的得分   1       https://study-cn.com/problems/score-after-flipping-matrix
168. Excel表列名称      1       https://study-cn.com/problems/excel-sheet-column-title
剑指 Offer 14- I. 剪绳子        1       https://study-cn.com/problems/jian-sheng-zi-lcof
96. 不同的二叉搜索树    1       https://study-cn.com/problems/unique-binary-search-trees
13. 罗马数字转整数      1       https://study-cn.com/problems/roman-to-integer
1190. 反转每对括号间的子串      1       https://study-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses
16. 最接近的三数之和    1       https://study-cn.com/problems/3sum-closest
216. 组合总和 III       1       https://study-cn.com/problems/combination-sum-iii
剑指 Offer 32 - II. 从上到下打印二叉树 II       1       https://study-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof
736. Lisp 语法解析      1       https://study-cn.com/problems/parse-lisp-expression
137. 只出现一次的数字 II        1       https://study-cn.com/problems/single-number-ii



















146. LRU缓存机制        32      https://study-cn.com/problems/lru-cache
206. 反转链表   30      https://study-cn.com/problems/reverse-linked-list
补充题4. 手撕快速排序   24      https://study-cn.com/problems/sort-an-array
21. 合并两个有序链表    18      https://study-cn.com/problems/merge-two-sorted-lists
470. 用 Rand7() 实现 Rand10()   15      https://study-cn.com/problems/implement-rand10-using-rand7
234. 回文链表   14      https://study-cn.com/problems/palindrome-linked-list
8. 字符串转换整数 (atoi)        13      https://study-cn.com/problems/string-to-integer-atoi
53. 最大子序和  12      https://study-cn.com/problems/maximum-subarray
460. LFU缓存    12      https://study-cn.com/problems/lfu-cache
215. 数组中的第K个最大元素      10      https://study-cn.com/problems/kth-largest-element-in-an-array
153. 寻找旋转排序数组中的最小值 10      https://study-cn.com/problems/find-minimum-in-rotated-sorted-array
3. 无重复字符的最长子串 10      https://study-cn.com/problems/longest-substring-without-repeating-characters
704. 二分查找   10      https://study-cn.com/problems/binary-search
415. 字符串相加 10      https://study-cn.com/problems/add-strings
补充题6. 手撕堆排序     9       https://study-cn.com/problems/sort-an-array
剑指 Offer 54. 二叉搜索树的第k大节点    9       https://study-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof
160. 相交链表   8       https://study-cn.com/problems/intersection-of-two-linked-lists
141. 环形链表   8       https://study-cn.com/problems/linked-list-cycle
151. 翻转字符串里的单词 8       https://study-cn.com/problems/reverse-words-in-a-string
4. 寻找两个正序数组的中位数     7       https://study-cn.com/problems/median-of-two-sorted-arrays
42. 接雨水      7       https://study-cn.com/problems/trapping-rain-water
102. 二叉树的层序遍历   7       https://study-cn.com/problems/binary-tree-level-order-traversal
144. 二叉树的前序遍历   7       https://study-cn.com/problems/binary-tree-preorder-traversal
300. 最长上升子序列     6       https://study-cn.com/problems/longest-increasing-subsequence
110. 平衡二叉树 6       https://study-cn.com/problems/balanced-binary-tree
2. 两数相加     6       https://study-cn.com/problems/add-two-numbers
70. 爬楼梯      6       https://study-cn.com/problems/climbing-stairs
213. 打家劫舍 II        6       https://study-cn.com/problems/house-robber-ii
5. 最长回文子串 6       https://study-cn.com/problems/longest-palindromic-substring
494. 目标和     6       https://study-cn.com/problems/target-sum
15. 三数之和    6       https://study-cn.com/problems/3sum
1. 两数之和     5       https://study-cn.com/problems/two-sum
239. 滑动窗口最大值     5       https://study-cn.com/problems/sliding-window-maximum
136. 只出现一次的数字   5       https://study-cn.com/problems/single-number
25. K 个一组翻转链表    5       https://study-cn.com/problems/reverse-nodes-in-k-group
232. 用栈实现队列       5       https://study-cn.com/problems/implement-queue-using-stacks
155. 最小栈     5       https://study-cn.com/problems/min-stack
104. 二叉树的最大深度   5       https://study-cn.com/problems/maximum-depth-of-binary-tree
剑指 Offer 22. 链表中倒数第k个节点      5       https://study-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof
322. 零钱兑换   5       https://study-cn.com/problems/coin-change
525. 连续数组   5       https://study-cn.com/problems/contiguous-array
169. 多数元素   4       https://study-cn.com/problems/majority-element
236. 二叉树的最近公共祖先       4       https://study-cn.com/problems/lowest-common-ancestor-of-a-binary-tree
328. 奇偶链表   4       https://study-cn.com/problems/odd-even-linked-list
9. 回文数       4       https://study-cn.com/problems/palindrome-number
112. 路径总和   4       https://study-cn.com/problems/path-sum
142. 环形链表 II        4       https://study-cn.com/problems/linked-list-cycle-ii
54. 螺旋矩阵    4       https://study-cn.com/problems/spiral-matrix
240. 搜索二维矩阵 II    4       https://study-cn.com/problems/search-a-2d-matrix-ii
20. 有效的括号  4       https://study-cn.com/problems/valid-parentheses
706. 设计哈希映射       4       https://study-cn.com/problems/design-hashmap
678. 有效的括号字符串   4       https://study-cn.com/problems/valid-parenthesis-string
补充题5. 手撕归并排序   4       https://study-cn.com/problems/sort-an-array
31. 下一个排列  4       https://study-cn.com/problems/next-permutation
33. 搜索旋转排序数组    4       https://study-cn.com/problems/search-in-rotated-sorted-array
199. 二叉树的右视图     4       https://study-cn.com/problems/binary-tree-right-side-view
887. 鸡蛋掉落   4       https://study-cn.com/problems/super-egg-drop
46. 全排列      4       https://study-cn.com/problems/permutations
88. 合并两个有序数组    4       https://study-cn.com/problems/merge-sorted-array
23. 合并K个排序链表     3       https://study-cn.com/problems/merge-k-sorted-lists
189. 旋转数组   3       https://study-cn.com/problems/rotate-array
59. 螺旋矩阵 II 3       https://study-cn.com/problems/spiral-matrix-ii
43. 字符串相乘  3       https://study-cn.com/problems/multiply-strings
384. 打乱数组   3       https://study-cn.com/problems/shuffle-an-array
172. 阶乘后的零 3       https://study-cn.com/problems/factorial-trailing-zeroes
227. 基本计算器 II      3       https://study-cn.com/problems/basic-calculator-ii
718. 最长重复子数组     3       https://study-cn.com/problems/maximum-length-of-repeated-subarray
394. 字符串解码 3       https://study-cn.com/problems/decode-string
69. x 的平方根  3       https://study-cn.com/problems/sqrtx
148. 排序链表   3       https://study-cn.com/problems/sort-list
143. 重排链表   3       https://study-cn.com/problems/reorder-list
121. 买卖股票的最佳时机 2       https://study-cn.com/problems/best-time-to-buy-and-sell-stock
37. 解数独      2       https://study-cn.com/problems/sudoku-solver
剑指 Offer 42. 连续子数组的最大和       2       https://study-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof
287. 寻找重复数 2       https://study-cn.com/problems/find-the-duplicate-number
129. 求根到叶子节点数字之和     2       https://study-cn.com/problems/sum-root-to-leaf-numbers
78. 子集        2       https://study-cn.com/problems/subsets
剑指 Offer 03. 数组中重复的数字 2       https://study-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof
93. 复原IP地址  2       https://study-cn.com/problems/restore-ip-addresses
82. 删除排序链表中的重复元素 II 2       https://study-cn.com/problems/remove-duplicates-from-sorted-list-ii
138. 复制带随机指针的链表       2       https://study-cn.com/problems/copy-list-with-random-pointer
113. 路径总和 II        2       https://study-cn.com/problems/path-sum-ii
剑指 Offer 65. 不用加减乘除做加法       2       https://study-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof
459. 重复的子字符串     2       https://study-cn.com/problems/repeated-substring-pattern
19. 删除链表的倒数第N个节点     2       https://study-cn.com/problems/remove-nth-node-from-end-of-list
11. 盛最多水的容器      2       https://study-cn.com/problems/container-with-most-water
26. 删除排序数组中的重复项      2       https://study-cn.com/problems/remove-duplicates-from-sorted-array
103. 二叉树的锯齿形层次遍历     2       https://study-cn.com/problems/binary-tree-zigzag-level-order-traversal
补充题21. 字符串相减    2       https://mp.weixin.qq.com/s/kCue4c0gnLSw0HosFl_t7w
907. 子数组的最小值之和 2       https://study-cn.com/problems/sum-of-subarray-minimums
补充题22. IP地址与整数的转换    2       https://mp.weixin.qq.com/s/u-RahFTB3JIqND41HqtotQ
692. 前K个高频单词      2       https://study-cn.com/problems/top-k-frequent-words
200. 岛屿数量   2       https://study-cn.com/problems/number-of-islands
14. 最长公共前缀        2       https://study-cn.com/problems/longest-common-prefix
118. 杨辉三角   2       https://study-cn.com/problems/pascals-triangle
剑指 Offer 57 - II. 和为s的连续正数序列 2       https://study-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof
剑指 Offer 40. 最小的k个数      2       https://study-cn.com/problems/zui-xiao-de-kge-shu-lcof
378. 有序矩阵中第K小的元素      2       https://study-cn.com/problems/kth-smallest-element-in-a-sorted-matrix
48. 旋转图像    2       https://study-cn.com/problems/rotate-image
480. 滑动窗口中位数     2       https://study-cn.com/problems/sliding-window-median
1095. 山脉数组中查找目标值      2       https://study-cn.com/problems/find-in-mountain-array
405. 数字转换为十六进制数       2       https://study-cn.com/problems/convert-a-number-to-hexadecimal
92. 反转链表 II 2       https://study-cn.com/problems/reverse-linked-list-ii
876. 链表的中间结点     2       https://study-cn.com/problems/middle-of-the-linked-list
剑指 Offer 24. 反转链表 1       https://study-cn.com/problems/fan-zhuan-lian-biao-lcof
409. 最长回文串 1       https://study-cn.com/problems/longest-palindrome
224. 基本计算器 1       https://study-cn.com/problems/basic-calculator
94. 二叉树的中序遍历    1       https://study-cn.com/problems/binary-tree-inorder-traversal
530. 二叉搜索树的最小绝对差     1       https://study-cn.com/problems/minimum-absolute-difference-in-bst
315. 计算右侧小于当前元素的个数 1       https://study-cn.com/problems/count-of-smaller-numbers-after-self
260. 只出现一次的数字 III       1       https://study-cn.com/problems/single-number-iii
679. 24 点游戏  1       https://study-cn.com/problems/24-game
994. 腐烂的橘子 1       https://study-cn.com/problems/rotting-oranges
588. 设计内存文件系统   1       https://study-cn.com/problems/design-in-memory-file-system
125. 验证回文串 1       https://study-cn.com/problems/valid-palindrome
41. 缺失的第一个正数    1       https://study-cn.com/problems/first-missing-positive
337. 打家劫舍 III       1       https://study-cn.com/problems/house-robber-iii
226. 翻转二叉树 1       https://study-cn.com/problems/invert-binary-tree
剑指 Offer 51. 数组中的逆序对   1       https://study-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof
补充题17. 两个有序数组第k小的数 1
217. 存在重复元素       1       https://study-cn.com/problems/contains-duplicate
242. 有效的字母异位词   1       https://study-cn.com/problems/valid-anagram
63. 不同路径 II 1       https://study-cn.com/problems/unique-paths-ii
74. 搜索二维矩阵        1       https://study-cn.com/problems/search-a-2d-matrix
701. 二叉搜索树中的插入操作     1       https://study-cn.com/problems/insert-into-a-binary-search-tree
1047. 删除字符串中的所有相邻重复项      1       https://study-cn.com/problems/remove-all-adjacent-duplicates-in-string
75. 颜色分类    1       https://study-cn.com/problems/sort-colors
补充题14. 阿拉伯数字转中文数字  1
134. 加油站     1       https://study-cn.com/problems/gas-station
231. 2的幂      1       https://study-cn.com/problems/power-of-two
451. 根据字符出现频率排序       1       https://study-cn.com/problems/sort-characters-by-frequency
24. 两两交换链表中的节点        1       https://study-cn.com/problems/swap-nodes-in-pairs
剑指 Offer 10- I. 斐波那契数列  1       https://study-cn.com/problems/fei-bo-na-qi-shu-lie-lcof
7. 整数反转     1       https://study-cn.com/problems/reverse-integer
316. 去除重复字母       1       https://study-cn.com/problems/remove-duplicate-letters
117. 填充每个节点的下一个右侧节点指针 II        1       https://study-cn.com/problems/populating-next-right-pointers-in-each-node-ii
61. 旋转链表    1       https://study-cn.com/problems/rotate-list
283. 移动零     1       https://study-cn.com/problems/move-zeroes
剑指 Offer 36. 二叉搜索树与双向链表     1       https://study-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof
128. 最长连续序列       1       https://study-cn.com/problems/longest-consecutive-sequence
1044. 最长重复子串      1       https://study-cn.com/problems/longest-duplicate-substring
76. 最小覆盖子串        1       https://study-cn.com/problems/minimum-window-substring
50. Pow(x, n)   1       https://study-cn.com/problems/powx-n
162. 寻找峰值   1       https://study-cn.com/problems/find-peak-element
208. 实现 Trie (前缀树) 1       https://study-cn.com/problems/implement-trie-prefix-tree
179. 最大数     1       https://study-cn.com/problems/largest-number
728. 自除数     1       https://study-cn.com/problems/self-dividing-numbers
391. 完美矩形   1       https://study-cn.com/problems/perfect-rectangle
523. 连续的子数组和     1       https://study-cn.com/problems/continuous-subarray-sum
137. 只出现一次的数字 II        1       https://study-cn.com/problems/single-number-ii
598. 范围求和 II        1       https://study-cn.com/problems/range-addition-ii
258. 各位相加   1       https://study-cn.com/problems/add-digits
443. 压缩字符串 1       https://study-cn.com/problems/string-compression
72. 编辑距离    1       https://study-cn.com/problems/edit-distance
292. Nim 游戏   1       https://study-cn.com/problems/nim-game
297. 二叉树的序列化与反序列化   1       https://study-cn.com/problems/serialize-and-deserialize-binary-tree
518. 零钱兑换 II        1       https://study-cn.com/problems/coin-change-2
剑指 Offer 11. 旋转数组的最小数字       1       https://study-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof
剑指 Offer 32 - III. 从上到下打印二叉树 III     1       https://study-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof
622. 设计循环队列       1       https://study-cn.com/problems/design-circular-queue
1299. 将每个元素替换为右侧最大元素      1       https://study-cn.com/problems/replace-elements-with-greatest-element-on-right-side
67. 二进制求和  1       https://study-cn.com/problems/add-binary
64. 最小路径和  1       https://study-cn.com/problems/minimum-path-sum
剑指 Offer 52. 两个链表的第一个公共节点 1       https://study-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof
560. 和为K的子数组      1       https://study-cn.com/problems/subarray-sum-equals-k
28. 实现 strStr()       1       https://study-cn.com/problems/implement-strstr
84. 柱状图中最大的矩形  1       https://study-cn.com/problems/largest-rectangle-in-histogram
295. 数据流的中位数     1       https://study-cn.com/problems/find-median-from-data-stream
225. 用队列实现栈       1       https://study-cn.com/problems/implement-stack-using-queues
剑指 Offer 09. 用两个栈实现队列 1       https://study-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof
442. 数组中重复的数据   1       https://study-cn.com/problems/find-all-duplicates-in-an-array
381. O(1) 时间插入、删除和获取随机元素 - 允许重复       1       https://study-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed
695. 岛屿的最大面积     1       https://study-cn.com/problems/max-area-of-island
111. 二叉树的最小深度   1       https://study-cn.com/problems/minimum-depth-of-binary-tree
567. 字符串的排列       1       https://study-cn.com/problems/permutation-in-string
107. 二叉树的层次遍历 II        1       https://study-cn.com/problems/binary-tree-level-order-traversal-ii
1219. 黄金矿工  1       https://study-cn.com/problems/path-with-maximum-gold
剑指 Offer 16. 数值的整数次方   1       https://study-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof

*/

//二分查找  快排
struct list_node {
    struct list_node* next;
    int data;
}

struct list_node *g_head;

void list_insert(struct list_node *new_node) {
    if (g_head == NULL) {
        g_head = new_node;
        break;
    }

    struct list_node* tmp = NULL;
    tmp = g_head;
    g_head->next = new_node;
    new_node->next = tmp->next;
}


void list_reverse(struct list_node *head) {
    
}


struct ListNode* reverseList(struct ListNode* head) {
    struct ListNode* newHead = NULL;
    while (head) {
        // 创建一个新节点
        struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        newNode->val = head->val;        
        // 将新节点插入到新链表的头部
        newNode->next = newHead;
        newHead = newNode;
        // 移动到原链表的下一个节点
        head = head->next;
    }
    return newHead;
}


int main()
{
    
}

/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */
/**
 * 
 * @param pHead ListNode类 
 * @return ListNode类
 */
struct ListNode* ReverseList(struct ListNode* pHead ) {
    // write code here
    struct ListNode *pre = NULL;
    struct ListNode *cur = pHead;
    struct ListNode *next = NULL;
    while(cur)
    {
        next = cur->next;
        cur->next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}



//K 个一组翻转链表
struct ListNode {
    int val;
    struct ListNode *next;
};
 /**
  * struct ListNode {
  *  int val;
  *  struct ListNode *next;
  * };
  */
 /**
  * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
  *
  * 
  * @param head ListNode类 
  * @param k int整型 
  * @return ListNode类
  */
 struct ListNode* reverseKGroup(struct ListNode* head, int k ) {
     // write code here
      //找到每次翻转的尾部
         struct ListNode* tail = head;
         //遍历k次到尾部
         for(int i = 0; i < k; i++){
             //如果不足k到了链表尾，直接返回，不翻转
             if(tail == NULL)
                 return head;
             tail = tail->next;
         }
         //翻转时需要的前序和当前节点
         struct ListNode* pre = NULL;
         struct ListNode* cur = head;
         //在到达当前段尾节点前
         while(cur != tail){
             //翻转
             struct ListNode* temp = cur->next;
             cur->next = pre;
             pre = cur;
             cur = temp;
         }
         //当前尾指向下一段要翻转的链表
         head->next = reverseKGroup(tail, k);
         return pre;
 }


 //给定一个字符串 s ，请你找出其中不含有重复字符的 最长  子串  的长度。   https://zhuanlan.zhihu.com/p/649412389
 //s = "abcabcbb"  因为无重复字符的最长子串是 "abc"，所以其长度为 3。
// 1.首先如何判断我们取得的字串内有重复字符，利用哈希表，将每一个进窗口的字符进入哈希表，每当新字符进入时就判断一下哈希表上对应的值是否存在。
// 2.如果存在的话，此时就要出窗口，将left不断右移，每右移一个，就将对应字符的哈希表减1，直到重复字符的哈希表值为1即可。
// 3.此时更新结果。

 int lengthOfLongestSubstring(char* s) {
     int n = strlen(s);
     int maxLength = 0;
     int start = 0;
     int end = 0;
     int charSet[128] = {0}; // 用于记录字符是否出现过
 
     while (end < n) {
         char currentChar = s[end];
         //说明出现过
         if (charSet[currentChar] == 0) {
             charSet[currentChar] = 1;
             end++;
             maxLength = (end - start > maxLength) ? (end - start) : maxLength;
         } else {
             charSet[s[start]] = 0;
             start++;
         }
     }
 
     return maxLength;
 }



/*
s1 = "ab" s2 = "eidbaooo" 返回true


s2 包含 s1 的排列之一 ("ba").
*/
 bool checkInclusion(char* s1, char* s2) {
     int len1 = 0, len2 = 0;
     while (s1[len1]!= '\0') len1++;
     while (s2[len2]!= '\0') len2++;
 
     if (len1 > len2) return false;
 
     int count1[26] = {0};
     int count2[26] = {0};
 
     for (int i = 0; i < len1; i++) {
         count1[s1[i] - 'a']++;
         count2[s2[i] - 'a']++;
     }
 
     for (int i = len1; i < len2; i++) {
         if (memcmp(count1, count2, sizeof(count1)) == 0) return true;
         count2[s2[i] - 'a']++;
         count2[s2[i - len1] - 'a']--;
     }
 
     return memcmp(count1, count2, sizeof(count1)) == 0;
 }



//LRU
#include <stdio.h>
#include <stdlib.h>
 
 // 定义双向链表节点
 typedef struct ListNode {
     int key;
     int value;
     struct ListNode *prev;
     struct ListNode *next;
 } ListNode;
 
 // 定义 LRU 缓存结构体
 typedef struct {
     int capacity;
     int size;
     ListNode *head;
     ListNode *tail;
     ListNode **hashMap;
 } LRUCache;
 
 // 创建新的双向链表节点
 ListNode *createNode(int key, int value) {
     ListNode *node = (ListNode *)malloc(sizeof(ListNode));
     node->key = key;
     node->value = value;
     node->prev = NULL;
     node->next = NULL;
     return node;
 }
 
 // 删除双向链表中的节点
 void deleteNode(ListNode *node) {
     if (node->prev)
         node->prev->next = node->next;
     if (node->next)
         node->next->prev = node->prev;
     free(node);
 }
 
 // 将节点移动到双向链表头部，表示最近使用
 void moveToHead(LRUCache *cache, ListNode *node) {
     if (node == cache->head)
         return;
     deleteNode(node);
     node->next = cache->head;
     if (cache->head)
         cache->head->prev = node;
     cache->head = node;
     if (!cache->tail)
         cache->tail = node;
 }
 
 // 初始化 LRU 缓存
 LRUCache *createLRUCache(int capacity) {
     LRUCache *cache = (LRUCache *)malloc(sizeof(LRUCache));
     cache->capacity = capacity;
     cache->size = 0;
     cache->head = NULL;
     cache->tail = NULL;
     cache->hashMap = (ListNode **)malloc(capacity * sizeof(ListNode *));
     for (int i = 0; i < capacity; i++)
         cache->hashMap[i] = NULL;
     return cache;
 }
 
 // 获取缓存中的值
 int get(LRUCache *cache, int key) {
     ListNode *node = cache->hashMap[key % cache->capacity];
     while (node && node->key!= key)
         node = node->next;
     if (node) {
         moveToHead(cache, node);
         return node->value;
     }
     return -1;
 }
 
 // 设置缓存中的值
 void put(LRUCache *cache, int key, int value) {
     ListNode *node = cache->hashMap[key % cache->capacity];
     while (node && node->key!= key)
         node = node->next;
     if (node) {
         node->value = value;
         moveToHead(cache, node);
     } else {
         ListNode *newNode = createNode(key, value);
         if (cache->size == cache->capacity) {
             ListNode *removed = cache->tail;
             cache->tail = cache->tail->prev;
             if (cache->tail)
                 cache->tail->next = NULL;
             cache->hashMap[removed->key % cache->capacity] = NULL;
             deleteNode(removed);
             cache->size--;
         }
         newNode->next = cache->head;
         if (cache->head)
             cache->head->prev = newNode;
         cache->head = newNode;
         if (!cache->tail)
             cache->tail = newNode;
         cache->hashMap[key % cache->capacity] = newNode;
         cache->size++;
     }
 }
 
 // 释放 LRU 缓存占用的内存
 void freeLRUCache(LRUCache *cache) {
     ListNode *current = cache->head;
     while (current) {
         ListNode *next = current->next;
         free(current);
         current = next;
     }
     free(cache->hashMap);
     free(cache);
 }
 
 int main() {
     LRUCache *cache = createLRUCache(2);
     put(cache, 1, 1);
     put(cache, 2, 2);
     printf("%d\n", get(cache, 1));
     put(cache, 3, 3);
     printf("%d\n", get(cache, 2));
     put(cache, 4, 4);
     printf("%d\n", get(cache, 1));
     printf("%d\n", get(cache, 3));
     printf("%d\n", get(cache, 4));
     freeLRUCache(cache);
     return 0;
 }

//快排取第K个数   快排图解https://blog.csdn.net/2301_80401288/article/details/141501102
#include <stdio.h>
 
 // 划分函数，用于快速排序
 int partition(int arr[], int low, int high) {
     int pivot = arr[high];
     int i = low - 1;
     for (int j = low; j < high; j++) {
         if (arr[j] >= pivot) {
             i++;
             int temp = arr[i];
             arr[i] = arr[j];
             arr[j] = temp;
         }
     }
     int temp = arr[i + 1];
     arr[i + 1] = arr[high];
     arr[high] = temp;
     return i + 1;
 }
 
 // 快速排序递归函数
 void quickSort(int arr[], int low, int high) {
     if (low < high) {
         int pivotIndex = partition(arr, low, high);
         quickSort(arr, low, pivotIndex - 1);
         quickSort(arr, pivotIndex + 1, high);
     }
 }
 
 // 找到数组中第 K 个最大元素
 int findKthLargest(int arr[], int n, int k) {
     quickSort(arr, 0, n - 1);
     return arr[k - 1];
 }
 
 int main() {
     int arr[] = {3, 2, 1, 5, 6, 4};
     int n = sizeof(arr) / sizeof(arr[0]);
     int k = 2;
     int result = findKthLargest(arr, n, k);
     printf("xxxxxxxxxxx %d\n", k, result);
     return 0;
 }






 #include <stdio.h>
#include <stdlib.h>

// 二叉树节点结构体
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 创建新节点
TreeNode* newTreeNode(int val) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->val = val;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// 插入节点
TreeNode* insertTreeNode(TreeNode* root, int val) {
    if (root == NULL) {
        return newTreeNode(val);
    }
    if (val < root->val) {
        root->left = insertTreeNode(root->left, val);
    } else {
        root->right = insertTreeNode(root->right, val);
    }
    return root;
}

// 前序遍历
void preOrderTraversal(TreeNode* root) {
    if (root == NULL) return;
    printf("%d ", root->val);
    preOrderTraversal(root->left);
    preOrderTraversal(root->right);
}

// 中序遍历
void inOrderTraversal(TreeNode* root) {
    if (root == NULL) return;
    inOrderTraversal(root->left);
    printf("%d ", root->val);
    inOrderTraversal(root->right);
}

// 后序遍历
void postOrderTraversal(TreeNode* root) {
    if (root == NULL) return;
    postOrderTraversal(root->left);
    postOrderTraversal(root->right);
    printf("%d ", root->val);
}


// 释放二叉树内存
void freeTree(TreeNode* root) {
    if (root == NULL) return;
    freeTree(root->left);
    freeTree(root->right);
    free(root);
}

// 锯齿形层次遍历二叉树
void zigzagLevelOrder(TreeNode* root) {
    if (root == NULL) return;

    // 使用队列实现层次遍历
    TreeNode** queue = (TreeNode**)malloc(sizeof(TreeNode*) * 1000);
    int front = 0, rear = 0;
    queue[rear++] = root;
    int level = 0;
    int leftToRight = 1;

    while (front < rear) {
        int size = rear - front;
        int* levelArray = (int*)malloc(sizeof(int) * size);
        int index = 0;

        for (int i = 0; i < size; i++) {
            TreeNode* current = queue[front++];
            levelArray[index++] = current->val;

            if (current->left) queue[rear++] = current->left;
            if (current->right) queue[rear++] = current->right;
        }

        if (!leftToRight) {
            for (int i = 0; i < index / 2; i++) {
                int temp = levelArray[i];
                levelArray[i] = levelArray[index - i - 1];
                levelArray[index - i - 1] = temp;
            }
        }

        for (int i = 0; i < index; i++) {
            printf("%d ", levelArray[i]);
        }
        printf("\n");

        free(levelArray);
        leftToRight =!leftToRight;
        level++;
    }

    free(queue);
}

int main() {
    TreeNode* root = NULL;
    root = insertTreeNode(root, 3);
    root = insertTreeNode(root, 9);
    root = insertTreeNode(root, 20);
    root = insertTreeNode(root, 15);
    root = insertTreeNode(root, 7);

    zigzagLevelOrder(root);

    freeTree(root);
    return 0;
}


//满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
//三数之和 参考https://baijiahao.baidu.com/s?id=1764792807745816217&wfr=spider&for=pc
#include <stdio.h>
#include <stdlib.h>

void threeSum(int* nums, int numsSize, int*** result, int* returnSize, int** returnColumnSizes) {
    *returnSize = 0;
    if (numsSize < 3) {
        return;
    }

    qsort(nums, numsSize, sizeof(int), (__compar_fn_t)compare);

    for (int i = 0; i < numsSize - 2; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) continue;

        int left = i + 1;
        int right = numsSize - 1;

        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) {
                (*returnSize)++;
                *result = (int**)realloc(*result, *returnSize * sizeof(int*));
                (*result)[*returnSize - 1] = (int*)malloc(3 * sizeof(int));
                (*result)[*returnSize - 1][0] = nums[i];
                (*result)[*returnSize - 1][1] = nums[left];
                (*result)[*returnSize - 1][2] = nums[right];

                while (left < right && nums[left] == nums[left + 1]) left++;
                while (left < right && nums[right] == nums[right - 1]) right--;

                left++;
                right--;
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }

    *returnColumnSizes = (int*)malloc(*returnSize * sizeof(int));
    for (int i = 0; i < *returnSize; i++) {
        (*returnColumnSizes)[i] = 3;
    }
}

int compare(const void* a, const void* b) {
    return ( *(int*)a - *(int*)b );
}

int main() {
    int nums[] = {-1, 0, 1, 2, -1, -4};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int** result;
    int returnSize;
    int* returnColumnSizes;

    threeSum(nums, numsSize, &result, &returnSize, &returnColumnSizes);

    for (int i = 0; i < returnSize; i++) {
        for (int j = 0; j < returnColumnSizes[i]; j++) {
            printf("%d ", result[i][j]);
        }
        printf("\n");
    }

    for (int i = 0; i < returnSize; i++) {
        free(result[i]);
    }
    free(result);
    free(returnColumnSizes);

    return 0;
}

//三数之和 代码 java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length && nums[i] <= 0; i++) {
            if (i > 0 && nums[i - 1] == nums[i]) continue;
            int p = i + 1, q = nums.length - 1;
            while (p < q && nums[q] >= 0) {
                int iv = nums[i], qv = nums[q], pv = nums[p], sum = iv + pv + qv;
                if (sum == 0) result.add(Arrays.asList(iv, pv, qv));
                if (sum > 0) while (q > 0 && nums[q] == qv) q--;
                else while (p < nums.length - 1 && nums[p] == pv) p++;
            }
        }
        return result;
    }
}



//卖股票的最佳时机  https://blog.csdn.net/m0_46202073/article/details/112395067
#include <stdio.h>
#include <stdlib.h>

int maxProfit(int* prices, int pricesSize) {
    int minPrice = prices[0];
    int maxProfit = 0;
    for (int i = 1; i < pricesSize; i++) {
        if (prices[i] < minPrice) {
            minPrice = prices[i];
        } else {
            int currentProfit = prices[i] - minPrice;
            if (currentProfit > maxProfit) {
                maxProfit = currentProfit;
            }
        }
    }
    return maxProfit;
}

int main() {
    int prices[] = {7, 1, 5, 3, 6, 4};
    int pricesSize = sizeof(prices) / sizeof(prices[0]);
    int result = maxProfit(prices, pricesSize);
    printf("lirun：%d\n", result);
    return 0;
}


//二叉树中两个节点的最近公共祖先
#include <stdio.h>
#include <stdlib.h>

// 二叉树节点结构
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};

// 创建新节点
struct TreeNode* newNode(int val) {
    struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    node->val = val;
    node->left = NULL;
    node->right = NULL;
    return node;
}

/*
在这个代码中，我们首先检查根节点是否为空，然后检查根节点是否为给定的节点之一或者它们的父节点。如果不是，
我们递归地在左子树和右子树中搜索。如果在左子树中找到了公共祖先，并且在右子树中也找到了公共祖先，那么根节
点就是最近的公共祖先。否则，我们只需要返回找到的任一公共祖先。
*/
// 寻找最近公共祖先
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    if (root == NULL || root == p || root == q) {
        return root;
    }
    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);
    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);
    if (left && right) {
        return root;
    }
    return left? left : right;
}

// 释放二叉树内存
void freeTree(struct TreeNode* root) {
    if (root == NULL) return;
    freeTree(root->left);
    freeTree(root->right);
    free(root);
}

int main() {
    // 创建二叉树
    struct TreeNode* root = newNode(3);
    root->left = newNode(5);
    root->right = newNode(1);
    root->left->left = newNode(6);
    root->left->right = newNode(2);
    root->right->left = newNode(0);
    root->right->right = newNode(8);
    root->left->right->left = newNode(7);
    root->left->right->right = newNode(4);

    struct TreeNode* p = root->left;
    struct TreeNode* q = root->left->right->right;

    struct TreeNode* result = lowestCommonAncestor(root, p, q);
    if (result) {
        printf("最近公共祖先的值为：%d\n", result->val);
    } else {
        printf("未找到最近公共祖先\n");
    }

    // 释放内存
    freeTree(root);

    return 0;
}



#include <stdio.h>
//接雨水 找到最高的那个柱子，把数组分成两部分，对于两部分都已经确定了一个边界高度了，所以对剩余的每个柱子至于确定一边的边界高度值，就可以直接计算出能接的雨水了。
int trap(int* height, int heightSize) {
    if (heightSize <= 2) {
        return 0;
    }
    int left = 0, right = heightSize - 1;
    int leftMax = 0, rightMax = 0;
    int ans = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
                leftMax = height[left];
            } else {
                ans += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                ans += rightMax - height[right];
            }
            right--;
        }
    }
    return ans;
}

//https://zhuanlan.zhihu.com/p/79811305
public int trap(int[] height) {
    int sum = 0;
    //最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2
    for (int i = 1; i < height.length - 1; i++) {
        int max_left = 0;
        //找出左边最高
        for (int j = i - 1; j >= 0; j--) {
            if (height[j] > max_left) {
                max_left = height[j];
            }
        }
        int max_right = 0;
        //找出右边最高
        for (int j = i + 1; j < height.length; j++) {
            if (height[j] > max_right) {
                max_right = height[j];
            }
        }
        //找出两端较小的
        int min = Math.min(max_left, max_right);
        //只有较小的一段大于当前列的高度才会有水，其他情况不会有水
        if (min > height[i]) {
            sum = sum + (min - height[i]);
        }
    }
    return sum;
}

int main() {
    int height[] = { 0,1,0,2,1,0,1,3,2,1,2,1 };
    int heightSize = sizeof(height) / sizeof(height[0]);
    int result = trap(height, heightSize);
    printf("水量为：%d\n", result);
    return 0;
}

//搜索旋转排序数组
//https://baijiahao.baidu.com/s?id=1778879597494232635&wfr=spider&for=pc
#include <stdio.h>

// 判断是否升序
int isSeq(int* nums, int low, int high) {
    if (low > high) return 0;  // pivot 左边无元素
    else if (nums[low] <= nums[high]) return 1;  // 相等：pivot 左仅有一个元素
    else return 0;
}

// 判断 target 是否在区间中
int isIn(int* nums, int low, int high, int target) {
    if (target >= nums[low] && target <= nums[high]) return 1;
    else return 0;
}

// 二分查找
int biSearch(int* nums, int low, int high, int target) {
    int pivot = (low + high) / 2;
    while (low <= high) {
        pivot = (low + high) / 2;
        if (nums[pivot] == target) return pivot;
        else if (target < nums[pivot]) high = pivot - 1;
        else if (target > nums[pivot]) low = pivot + 1;
    }
    if (nums[low] == target) 
        return low;
    else 
        return -1;
}

int search(int* nums, int numSize, int target) {
    int low = 0, high = numSize - 1;
    while (low < high) {
        int pivot = (low + high) / 2;
        // 递归出口
        if (nums[pivot] == target) return pivot;
        int tIsIn = 0;
        // 判断左边是否升序
        int leftIsSeq = isSeq(nums, low, pivot - 1);
        if (leftIsSeq) {
            // 左边有序
            tIsIn = isIn(nums, low, pivot - 1, target);
            if (tIsIn) 
                return biSearch(nums, low, pivot - 1, target);
            else 
                low = pivot + 1;
        } else {
            // 右边有序
            tIsIn = isIn(nums, pivot + 1, high, target);
            if (tIsIn) 
                return biSearch(nums, pivot + 1, high, target);
            else 
                high = pivot - 1;
        }
    }
    if (nums[low] == target) return low;
    else return -1;
}

/*
下一个排列 https://zhuanlan.zhihu.com/p/333504418
*/

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums[i], nums[j]);
        }
        reverse(nums.begin() + i + 1, nums.end());
    }
};


//重排链表 https://blog.csdn.net/qq_44630255/article/details/137616260
#include <iostream>
#include <vector>

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    void reorderList(ListNode* head) {
        if (!head || !head->next) return; // 如果链表为空或只有一个节点，无需重排

        // 找到链表的中间节点
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // 反转后半部分链表
        ListNode* pre = nullptr;
        ListNode* cur = slow->next;
        slow->next = nullptr; // 断开前后两部分链表
        while (cur) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }

        // 合并两部分链表
        ListNode* p1 = head;
        ListNode* p2 = pre;
        while (p2) {
            ListNode* tmp1 = p1->next;
            ListNode* tmp2 = p2->next;
            p1->next = p2;
            p2->next = tmp1;
            p1 = tmp1;
            p2 = tmp2;
        }
    }
};

// 创建链表
ListNode* createList(std::vector<int>& nums) {
    if (nums.empty()) return nullptr;
    ListNode* head = new ListNode(nums[0]);
    ListNode* cur = head;
    for (int i = 1; i < nums.size(); ++i) {
        cur->next = new ListNode(nums[i]);
        cur = cur->next;
    }
    return head;
}

// 输出链表
void printList(ListNode* head) {
    ListNode* cur = head;
    while (cur) {
        std::cout << cur->val << " ";
        cur = cur->next;
    }
    std::cout << std::endl;
}

int main() 
{
    std::vector<int> nums = {1, 2, 3, 4, 5};
    ListNode* head = createList(nums);

    // 重排链表
    Solution solution;
    solution.reorderList(head);

    // 输出重排后的链表
    printList(head);

    return 0;
}

//合并两个有序链表
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode res = new ListNode();
    ListNode tempNode = res;
    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            tempNode.next = list1;
            list1 = list1.next;
        } else {
            tempNode.next = list2;
            list2 = list2.next;
        }
        tempNode = tempNode.next;
    }
    if (list1 == null) {
        tempNode.next = list2;
    }
    if (list2 == null) {
        tempNode.next = list1;
    }
    return res.next;
}



